Road Navigation-----------------------------------------------------------------------
from collections import deque

# Read number of roads
N = int(input().strip())

# Read road definitions
roads = []
for _ in range(N):
    x1, y1, x2, y2 = map(int, input().split())
    roads.append((x1, y1, x2, y2))

# Read starting and destination positions
start_x, start_y = map(int, input().split())
dest_x, dest_y = map(int, input().split())
start = (start_x, start_y)
dest = (dest_x, dest_y)

# Build adjacency list for the road graph
adjacency = {}  # dictionary: point -> list of neighboring points
allowed_points = set()  # set of all points that lie on any road

for (x1, y1, x2, y2) in roads:
    # Normalize coordinates (ensure x1 <= x2 and y1 <= y2 for iteration)
    if x1 == x2:  # vertical road
        x = x1
        y_start, y_end = sorted([y1, y2])
        for y in range(y_start, y_end + 1):
            allowed_points.add((x, y))
        # Add edges between consecutive vertical points
        for y in range(y_start, y_end):
            p1 = (x, y)
            p2 = (x, y + 1)
            # Initialize adjacency entries if not present
            adjacency.setdefault(p1, []).append(p2)
            adjacency.setdefault(p2, []).append(p1)
    elif y1 == y2:  # horizontal road
        y = y1
        x_start, x_end = sorted([x1, x2])
        for x in range(x_start, x_end + 1):
            allowed_points.add((x, y))
        # Add edges between consecutive horizontal points
        for x in range(x_start, x_end):
            p1 = (x, y)
            p2 = (x + 1, y)
            adjacency.setdefault(p1, []).append(p2)
            adjacency.setdefault(p2, []).append(p1)
    # (If a road is a single point x1==x2 and y1==y2, handle below)

# If any road was just a single point, ensure it's in adjacency (as isolated node)
for (x1, y1, x2, y2) in roads:
    if x1 == x2 and y1 == y2:
        p = (x1, y1)
        allowed_points.add(p)
        adjacency.setdefault(p, [])  # no neighbors because it's a single-point road

# Check if start and destination are on the road network
if start not in allowed_points or dest not in allowed_points:
    print("Impossible.")
    exit(0)

# If start equals destination, shortest distance is 0
if start == dest:
    print(0)
    exit(0)

# BFS initialization
queue = deque()
queue.append((start, 0))  # (point, distance)
visited = {start}

result_distance = None

# Perform BFS
while queue:
    current_point, dist = queue.popleft()
    # Check if reached destination
    if current_point == dest:
        result_distance = dist
        break
    # Traverse neighbors
    for neighbor in adjacency.get(current_point, []):
        if neighbor not in visited:
            visited.add(neighbor)
            queue.append((neighbor, dist + 1))

# Output result
if result_distance is not None:
    print(result_distance)
else:
    print("Impossible.")




