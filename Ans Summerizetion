4.
def solve():
    import sys
    from math import gcd
    from collections import deque
    
    # Step 1: Read number of roads.
    input_line = sys.stdin.readline().strip()
    while not input_line:  # skip any empty lines
        input_line = sys.stdin.readline().strip()
    N = int(input_line)
    
    # Step 2: Read the N roads.
    roads = []
    for _ in range(N):
        line = sys.stdin.readline().strip()
        while not line:  # skip empty lines if they occur
            line = sys.stdin.readline().strip()
        x1, y1, x2, y2 = map(int, line.split())
        roads.append((x1, y1, x2, y2))
    
    # Step 3: Read Rahul's current position (start).
    line = sys.stdin.readline().strip()
    while not line:
        line = sys.stdin.readline().strip()
    x_s, y_s = map(int, line.split())
    
    # Step 4: Read Rahul's destination.
    line = sys.stdin.readline().strip()
    while not line:
        line = sys.stdin.readline().strip()
    x_g, y_g = map(int, line.split())
    
    # Step 5: Prepare data structures for the graph.
    vertex_id = {}  # maps (x, y) -> integer index
    edges = []      # adjacency list; edges[i] = list of neighbors of vertex i
    
    def add_vertex(point):
        """Map the (x, y) 'point' to a unique vertex index, creating if needed."""
        if point not in vertex_id:
            vertex_id[point] = len(edges)
            edges.append([])
        return vertex_id[point]
    
    def add_edge(p1, p2):
        """Add a bidirectional edge between lattice points p1 and p2 with cost 1."""
        v1 = add_vertex(p1)
        v2 = add_vertex(p2)
        edges[v1].append(v2)
        edges[v2].append(v1)
    
    # Step 6: Convert each road into discrete lattice points and build graph edges.
    for (x1, y1, x2, y2) in roads:
        dx = x2 - x1
        dy = y2 - y1
        
        # Zero-length road:
        if dx == 0 and dy == 0:
            add_vertex((x1, y1))
            continue
        
        # gcd-based step to list all integer points on this road
        g = gcd(abs(dx), abs(dy))
        step_x = dx // g
        step_y = dy // g
        
        # Generate all points from (x1, y1) up to (x2, y2) in unit steps
        px, py = x1, y1
        points_on_road = []
        for _ in range(g + 1):
            points_on_road.append((px, py))
            px += step_x
            py += step_y
        
        # Connect consecutive points on the road
        for i in range(len(points_on_road) - 1):
            add_edge(points_on_road[i], points_on_road[i+1])
    
    # Step 7: Ensure start and goal exist in the graph
    if (x_s, y_s) not in vertex_id or (x_g, y_g) not in vertex_id:
        print("Impossible.")
        return
    
    start_idx = vertex_id[(x_s, y_s)]
    goal_idx = vertex_id[(x_g, y_g)]
    
    # Step 8: BFS for shortest path (number of edges).
    dist = [-1] * len(edges)
    dist[start_idx] = 0
    
    queue = deque([start_idx])
    
    while queue:
        u = queue.popleft()
        if u == goal_idx:
            print(dist[u])
            return
        for v in edges[u]:
            if dist[v] == -1:  # unvisited
                dist[v] = dist[u] + 1
                queue.append(v)
    
    # If goal wasn't reached, it's impossible.
    print("Impossible.")
