4. New code
def solve():
    import sys
    from collections import deque
    from math import gcd

    data = sys.stdin.read().strip().split()
    idx = 0
    
    # Read the number of roads
    N = int(data[idx])
    idx += 1
    
    roads = []
    for _ in range(N):
        x1 = int(data[idx]);   y1 = int(data[idx+1])
        x2 = int(data[idx+2]); y2 = int(data[idx+3])
        idx += 4
        roads.append((x1, y1, x2, y2))
    
    # Read start and destination coordinates
    x_s = int(data[idx]); y_s = int(data[idx+1])
    x_g = int(data[idx+2]); y_g = int(data[idx+3])
    idx += 4
    
    # Graph storage: 'vertex_id' maps each point (x,y) to an index,
    # and 'edges' is the adjacency list.
    vertex_id = {}
    edges = []
    
    def add_vertex(p):
        """Add a vertex for point p=(x,y) if not already present.
           Return its index."""
        if p not in vertex_id:
            vertex_id[p] = len(edges)
            edges.append([])
        return vertex_id[p]
    
    def add_edge(p1, p2):
        """Add a bidirectional edge between points p1 and p2 with cost 1."""
        v1 = add_vertex(p1)
        v2 = add_vertex(p2)
        edges[v1].append(v2)
        edges[v2].append(v1)
    
    # Build the graph: for each road, compute all lattice points and connect them.
    for (x1, y1, x2, y2) in roads:
        dx = x2 - x1
        dy = y2 - y1
        
        # Handle zero-length road (degenerate case).
        if dx == 0 and dy == 0:
            add_vertex((x1, y1))
            continue
        
        # Compute the number of steps using the GCD.
        g = gcd(abs(dx), abs(dy))
        step_x = dx // g
        step_y = dy // g
        
        # Generate all lattice points along the road.
        px, py = x1, y1
        points_on_road = []
        for _ in range(g + 1):
            points_on_road.append((px, py))
            px += step_x
            py += step_y
        
        # Connect consecutive lattice points.
        for i in range(len(points_on_road) - 1):
            add_edge(points_on_road[i], points_on_road[i+1])
    
    # If the start or goal is not on any road, output "Impossible."
    if (x_s, y_s) not in vertex_id or (x_g, y_g) not in vertex_id:
        print("Impossible.")
        return
    
    start_v = vertex_id[(x_s, y_s)]
    goal_v = vertex_id[(x_g, y_g)]
    
    # BFS for shortest path (each edge has cost 1)
    dist = [-1] * len(edges)
    dist[start_v] = 0
    queue = deque([start_v])
    
    while queue:
        u = queue.popleft()
        if u == goal_v:
            print(dist[u])
            return
        for v in edges[u]:
            if dist[v] == -1:
                dist[v] = dist[u] + 1
                queue.append(v)
    
    # If goal is unreachable, output "Impossible."
    print("Impossible.")




3. check this one
def solve():
    import sys
    data = sys.stdin.read().strip().split('\n')

    # 1) Parse Input
    N = int(data[0])
    substrings = []
    for i in range(1, N+1):
        s, c, w = data[i].split()
        substrings.append((s, int(c), int(w)))
    main_string = data[N+1]
    
    # 2) Part 1: Min Cost to Cover Main String
    T = main_string
    m = len(T)
    INF = 10**15
    
    dp = [INF] * (m + 1)
    dp[0] = 0
    parent_index = [-1] * (m + 1)
    parent_sub = [-1] * (m + 1)

    def build_advance_table(sub, T):
        """ Returns an array where advance[i] is the next index in T after matching 'sub' from i. """
        m = len(T)
        adv = [0] * (m + 1)
        for i in range(m + 1):
            p = i
            for c in sub:
                while p < m and T[p] != c:
                    p += 1
                if p < m:
                    p += 1
            adv[i] = p
        return adv

    advance_tables = [build_advance_table(s, T) for s, _, _ in substrings]

    for i in range(m + 1):
        if dp[i] == INF:
            continue
        for j, (s, cost_j, weight_j) in enumerate(substrings):
            nxt = advance_tables[j][i]
            if nxt <= m:
                new_cost = dp[i] + cost_j
                if new_cost < dp[nxt]:
                    dp[nxt] = new_cost
                    parent_index[nxt] = i
                    parent_sub[nxt]   = j

    # Backtrack to find chosen substrings
    usage_counts = [0] * N
    cur = m
    while cur > 0:
        p = parent_index[cur]
        j = parent_sub[cur]
        usage_counts[j] += 1
        cur = p

    # 3) Part 2: Build Maximum Ladder
    items = []
    for i, (s, c, w) in enumerate(substrings):
        if usage_counts[i] > 0:
            ability = sum(ord(ch) - ord('a') + 1 for ch in s)
            for _ in range(usage_counts[i]):
                items.append((ability, w))

    if not items:
        print(0)
        return

    # Sort descending by ability
    items.sort(reverse=True, key=lambda x: x[0])
    M = len(items)
    max_weight = sum(w for _, w in items)

    # 1D DP to store max stack height at given weight
    dp_height = [0] * (max_weight + 1)

    for ability, weight in items:
        for w in range(max_weight, -1, -1):  # Traverse in reverse
            if w <= ability and w + weight <= max_weight:
                dp_height[w + weight] = max(dp_height[w + weight], dp_height[w] + 1)

    print(max(dp_height))

