import sys
import collections

# Sometimes a deep backtracking can exceed Python's default recursion limit (~1000).
# If N/M is larger (like 5x5 sub-sheets or so), you might need to raise it:
sys.setrecursionlimit(10**7)

def solve():
    # 1) READ INPUTS
    raw = input().strip().split()
    N, M = map(int, raw)  # first line: N, M

    # Read next N lines; each line has exactly N characters (no spaces in between)
    raw_map = []
    for _ in range(N):
        line = input().rstrip('\n')
        # Each line is a string of length N containing L, T, S, D
        raw_map.append(list(line))
    
    k = N // M  # how many sub-sheets in one dimension
    total_sheets = k * k

    # 2) EXTRACT SUB-SHEETS (each of size MxM)
    sub_sheets = []
    for r in range(k):
        for c in range(k):
            block = []
            row_start = r * M
            col_start = c * M
            for rr in range(M):
                row_data = raw_map[row_start + rr][col_start : col_start + M]
                block.append(row_data)
            sub_sheets.append(block)

    # 3) FIND WHICH SUB-SHEETS CONTAIN 'S' AND 'D'
    index_of_S = None
    index_of_D = None
    for i, sheet in enumerate(sub_sheets):
        for rr in range(M):
            for cc in range(M):
                if sheet[rr][cc] == 'S':
                    index_of_S = i
                elif sheet[rr][cc] == 'D':
                    index_of_D = i
    
    # Safety check in case input is malformed
    if index_of_S is None or index_of_D is None:
        # The problem statement implies we always have one S and one D
        # but let's handle the case gracefully
        print(-1)
        return

    # 4) PRECOMPUTE BOUNDARY COMPATIBILITY
    #
    #    right_compat[i][j] = True  if sub_sheets[i] can be placed immediately
    #                          to the LEFT  of sub_sheets[j]
    #    down_compat[i][j]  = True  if sub_sheets[i] can be placed immediately
    #                          ABOVE        sub_sheets[j]
    #
    # Matching rule: If one boundary cell is T/S/D, the adjacent must also be T/S/D.
    #                If one boundary cell is L, the other must be L.
    #
    # We'll treat 'S'/'D' as 'T' for boundary-checking purposes.

    def boundary_type(ch):
        # convert 'S' or 'D' to 'T' for boundary checks
        if ch in ('S','D'):
            return 'T'
        return ch

    def match_ok(a, b):
        return (boundary_type(a) == boundary_type(b))

    right_compat = [[False]*total_sheets for _ in range(total_sheets)]
    down_compat  = [[False]*total_sheets for _ in range(total_sheets)]

    for i in range(total_sheets):
        A = sub_sheets[i]
        # right edge of A
        right_edge_A = [A[r][M-1] for r in range(M)]
        # bottom edge of A
        bottom_edge_A = A[M-1]

        for j in range(total_sheets):
            if i == j:
                continue
            B = sub_sheets[j]
            # left edge of B
            left_edge_B = [B[r][0] for r in range(M)]
            # top edge of B
            top_edge_B  = B[0]

            # Horizontal check: A's right edge vs B's left edge
            horizontal_ok = True
            for r in range(M):
                if not match_ok(right_edge_A[r], left_edge_B[r]):
                    horizontal_ok = False
                    break

            # Vertical check: A's bottom edge vs B's top edge
            vertical_ok = True
            for c in range(M):
                if not match_ok(bottom_edge_A[c], top_edge_B[c]):
                    vertical_ok = False
                    break

            right_compat[i][j] = horizontal_ok
            down_compat[i][j]  = vertical_ok

    # 5) BACKTRACKING TO ARRANGE SUB-SHEETS

    final_layout = [[None]*k for _ in range(k)]
    used = [False]*total_sheets

    # Place S-sheet at (0,0), D-sheet at (k-1,k-1)
    final_layout[0][0] = index_of_S
    used[index_of_S] = True
    final_layout[k-1][k-1] = index_of_D
    used[index_of_D] = True

    best_distance = None  # to store the minimum BFS distance

    # Helper to build the NxN map from final_layout and run BFS from S to D
    def build_full_map_and_bfs():
        # Build NxN from the sub-sheets
        big_map = [['?']*N for _ in range(N)]
        for r in range(k):
            for c in range(k):
                sheet_idx = final_layout[r][c]
                block = sub_sheets[sheet_idx]
                # copy MxM block into position
                row_start = r*M
                col_start = c*M
                for rr in range(M):
                    for cc in range(M):
                        big_map[row_start + rr][col_start + cc] = block[rr][cc]

        # Find S and D in big_map
        s_pos = None
        d_pos = None
        for rr in range(N):
            for cc in range(N):
                if big_map[rr][cc] == 'S':
                    s_pos = (rr, cc)
                elif big_map[rr][cc] == 'D':
                    d_pos = (rr, cc)

        if not s_pos or not d_pos:
            return None  # shouldn't happen in a correct puzzle

        # BFS
        visited = [[False]*N for _ in range(N)]
        q = collections.deque()
        # distance = 1 at S (including the S cell itself)
        q.append((s_pos[0], s_pos[1], 1))
        visited[s_pos[0]][s_pos[1]] = True

        while q:
            r, c, dist = q.popleft()
            if (r, c) == d_pos:
                return dist

            for (dr, dc) in [(-1,0),(1,0),(0,-1),(0,1)]:
                nr, nc = r+dr, c+dc
                if 0 <= nr < N and 0 <= nc < N and not visited[nr][nc]:
                    ch = big_map[nr][nc]
                    # passable if T/S/D
                    if ch in ('T','S','D'):
                        visited[nr][nc] = True
                        q.append((nr, nc, dist+1))
        return None

    def backtrack(pos):
        nonlocal best_distance

        # If we've assigned all k*k positions, evaluate BFS distance
        if pos == k*k:
            dist = build_full_map_and_bfs()
            if dist is not None:
                if best_distance is None or dist < best_distance:
                    best_distance = dist
            return

        # row, col in the sub-sheet layout
        r = pos // k
        c = pos % k

        # If already assigned (S or D corners), skip
        if final_layout[r][c] is not None:
            backtrack(pos+1)
            return

        # Try placing each unused sub-sheet here, check boundaries
        for sheet_idx in range(total_sheets):
            if not used[sheet_idx]:
                # check left neighbor boundary
                if c > 0:
                    left_sheet = final_layout[r][c-1]
                    if not right_compat[left_sheet][sheet_idx]:
                        continue
                # check up neighbor boundary
                if r > 0:
                    up_sheet = final_layout[r-1][c]
                    if not down_compat[up_sheet][sheet_idx]:
                        continue

                # place
                final_layout[r][c] = sheet_idx
                used[sheet_idx] = True

                backtrack(pos+1)

                # remove
                final_layout[r][c] = None
                used[sheet_idx] = False

    # Start backtracking from position 0
    backtrack(0)

    # Print result
    # If best_distance stayed None, no arrangement gave an S->D path
    if best_distance is None:
        # Problem states there's always a valid arrangement,
        # but if not, we can print 0 or -1 to indicate no path.
        print(0)
    else:
        print(best_distance)
