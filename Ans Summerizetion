1.
#include <bits/stdc++.h>
using namespace std;

/*
  The puzzle constraints:
    - 6 <= N <= 25
    - 3 <= M <= 5
    - N is a multiple of M
    - Exactly one 'S' and one 'D'
    - Sub-sheets of size MxM can be rearranged in a k x k grid (k = N/M),
      with 'S' sub-sheet forced at (0,0) and 'D' sub-sheet forced at (k-1,k-1).
    - We want the shortest track distance from S to D (counting both S and D).
*/

///////////////////////////////////////////////
// 1) Read Input
///////////////////////////////////////////////
void readInput(int &N, int &M, vector<vector<char>> &rawMap) {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> N >> M;  // first line: N, M
    rawMap.resize(N, vector<char>(N));

    for(int r = 0; r < N; r++){
        // Each line has N characters (e.g. "LLLLLL")
        // Make sure you read them as a contiguous string with no spaces in between
        string line;
        cin >> line; // read a string of length N
        for(int c = 0; c < N; c++){
            rawMap[r][c] = line[c];
        }
    }
}


///////////////////////////////////////////////
// 2) Extract MxM sub-sheets from the NxN map
///////////////////////////////////////////////
vector<vector<vector<char>>> extractSubSheets(int N, int M, const vector<vector<char>> &rawMap) {
    // k = N / M
    int k = N / M;
    // We'll store sub-sheets in row-major order as they appear in the input
    // Each sub-sheet is an MxM block
    vector<vector<vector<char>>> subSheets; 
    subSheets.reserve(k * k);

    for(int r = 0; r < k; r++){
        for(int c = 0; c < k; c++){
            vector<vector<char>> block(M, vector<char>(M));
            int rowStart = r * M;
            int colStart = c * M;
            for(int rr = 0; rr < M; rr++){
                for(int cc = 0; cc < M; cc++){
                    block[rr][cc] = rawMap[rowStart + rr][colStart + cc];
                }
            }
            subSheets.push_back(block);
        }
    }
    return subSheets;
}


///////////////////////////////////////////////
// 3) Identify which sub-sheet contains 'S' or 'D'
///////////////////////////////////////////////
pair<int,int> findSD(const vector<vector<vector<char>>> &subSheets) {
    // returns {index_of_S, index_of_D}
    int index_of_S = -1;
    int index_of_D = -1;

    for(int i = 0; i < (int)subSheets.size(); i++){
        int M = (int)subSheets[i].size(); // each sub-sheet is MxM
        for(int r = 0; r < M; r++){
            for(int c = 0; c < M; c++){
                if(subSheets[i][r][c] == 'S'){
                    index_of_S = i;
                }
                else if(subSheets[i][r][c] == 'D'){
                    index_of_D = i;
                }
            }
        }
    }
    return make_pair(index_of_S, index_of_D);
}


///////////////////////////////////////////////
// 4) Precompute boundary compatibility
//    rightCompat[i][j] = true if subSheets[i] can be placed
//        immediately to the left of subSheets[j] (matching vertical boundary).
//    downCompat[i][j] = true if subSheets[i] can be placed
//        immediately above subSheets[j] (matching horizontal boundary).
///////////////////////////////////////////////
bool matchOk(char a, char b) {
    // 'S'/'D' are treated like 'T' for boundary checks
    auto boundaryType = [&](char ch){
        if(ch == 'S' || ch == 'D') return 'T';
        return ch;
    };
    return boundaryType(a) == boundaryType(b);
}

void precomputeCompatibility(
    const vector<vector<vector<char>>> &subSheets,
    vector<vector<bool>> &rightCompat,
    vector<vector<bool>> &downCompat
){
    int total = (int)subSheets.size();
    int M = (int)subSheets[0].size();

    rightCompat.assign(total, vector<bool>(total, false));
    downCompat.assign(total, vector<bool>(total, false));

    for(int i = 0; i < total; i++){
        // right edge of subSheets[i]
        vector<char> rightEdge(M), bottomEdge(M);
        for(int r = 0; r < M; r++){
            rightEdge[r] = subSheets[i][r][M-1];
        }
        for(int c = 0; c < M; c++){
            bottomEdge[c] = subSheets[i][M-1][c];
        }

        for(int j = 0; j < total; j++){
            if(i == j) continue;
            // left edge of subSheets[j], top edge of subSheets[j]
            vector<char> leftEdge(M), topEdge(M);
            for(int r = 0; r < M; r++){
                leftEdge[r] = subSheets[j][r][0];
            }
            for(int c = 0; c < M; c++){
                topEdge[c] = subSheets[j][0][c];
            }

            // check horizontal boundary (i->right vs j->left)
            bool horizOK = true;
            for(int r = 0; r < M && horizOK; r++){
                if(!matchOk(rightEdge[r], leftEdge[r])){
                    horizOK = false;
                }
            }
            // check vertical boundary (i->bottom vs j->top)
            bool vertOK = true;
            for(int c = 0; c < M && vertOK; c++){
                if(!matchOk(bottomEdge[c], topEdge[c])){
                    vertOK = false;
                }
            }
            rightCompat[i][j] = horizOK;
            downCompat[i][j]  = vertOK;
        }
    }
}


///////////////////////////////////////////////
// 5) Build the full NxN map from the final layout
///////////////////////////////////////////////
vector<vector<char>> buildFullMap(
    const vector<vector<int>> &finalLayout,
    const vector<vector<vector<char>>> &subSheets,
    int N, int M
){
    int k = N / M;
    vector<vector<char>> bigMap(N, vector<char>(N, '?'));

    for(int r = 0; r < k; r++){
        for(int c = 0; c < k; c++){
            int sheetIdx = finalLayout[r][c];
            const auto &block = subSheets[sheetIdx];
            int rowStart = r * M;
            int colStart = c * M;
            for(int rr = 0; rr < M; rr++){
                for(int cc = 0; cc < M; cc++){
                    bigMap[rowStart+rr][colStart+cc] = block[rr][cc];
                }
            }
        }
    }
    return bigMap;
}


///////////////////////////////////////////////
// 6) BFS from 'S' to 'D' to find shortest path
//    counting both S and D in the distance
///////////////////////////////////////////////
int bfsShortestPath(const vector<vector<char>> &bigMap, int N){
    // locate S, D
    pair<int,int> sPos(-1, -1);
    pair<int,int> dPos(-1, -1);

    for(int r = 0; r < N; r++){
        for(int c = 0; c < N; c++){
            if(bigMap[r][c] == 'S'){
                sPos = {r, c};
            } else if(bigMap[r][c] == 'D'){
                dPos = {r, c};
            }
        }
    }
    if(sPos.first == -1 || dPos.first == -1){
        // no S or D found
        return -1;
    }

    // BFS
    vector<vector<bool>> visited(N, vector<bool>(N, false));
    queue<array<int,3>>q; 
    // store {row, col, dist}
    q.push({sPos.first, sPos.second, 1});
    visited[sPos.first][sPos.second] = true;

    // valid moves: up, down, left, right
    int dirs[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};

    while(!q.empty()){
        auto [r, c, dist] = q.front(); 
        q.pop();

        if(r == dPos.first && c == dPos.second){
            return dist; // found D
        }

        for(auto &d : dirs){
            int nr = r + d[0], nc = c + d[1];
            if(nr >= 0 && nr < N && nc >= 0 && nc < N && !visited[nr][nc]){
                char ch = bigMap[nr][nc];
                // passable if T,S,D
                if(ch == 'T' || ch == 'S' || ch == 'D'){
                    visited[nr][nc] = true;
                    q.push({nr, nc, dist+1});
                }
            }
        }
    }
    return -1; // no path found
}


///////////////////////////////////////////////
// 7) Backtracking to place sub-sheets in a k x k grid
//    We fix the sub-sheet with S at (0,0) and with D at (k-1, k-1).
///////////////////////////////////////////////
void backtrack(
    int pos,
    vector<vector<int>> &finalLayout,
    vector<bool> &used,
    const vector<vector<bool>> &rightCompat,
    const vector<vector<bool>> &downCompat,
    const vector<vector<vector<char>>> &subSheets,
    int N, int M,
    int &bestDist
){
    int k = N / M;
    if(pos == k*k){
        // All sub-sheets are placed; build the NxN map and BFS
        auto bigMap = buildFullMap(finalLayout, subSheets, N, M);
        int dist = bfsShortestPath(bigMap, N);
        if(dist > 0){
            if(bestDist < 0 || dist < bestDist){
                bestDist = dist;
            }
        }
        return;
    }

    int r = pos / k;
    int c = pos % k;

    // If (r,c) is already forced (S or D sub-sheet), skip
    if(finalLayout[r][c] != -1){
        backtrack(pos+1, finalLayout, used, rightCompat, downCompat,
                  subSheets, N, M, bestDist);
        return;
    }

    int total = (int)subSheets.size();
    // Try every unused sub-sheet
    for(int sheetIdx = 0; sheetIdx < total; sheetIdx++){
        if(!used[sheetIdx]){
            // Check boundary with left
            if(c > 0){
                int leftSheet = finalLayout[r][c-1];
                // must match horizontally
                if(!rightCompat[leftSheet][sheetIdx]){
                    continue;
                }
            }
            // Check boundary with above
            if(r > 0){
                int upSheet = finalLayout[r-1][c];
                // must match vertically
                if(!downCompat[upSheet][sheetIdx]){
                    continue;
                }
            }

            // Place
            finalLayout[r][c] = sheetIdx;
            used[sheetIdx] = true;

            backtrack(pos+1, finalLayout, used, rightCompat, downCompat,
                      subSheets, N, M, bestDist);

            // Undo
            finalLayout[r][c] = -1;
            used[sheetIdx] = false;
        }
    }
}


///////////////////////////////////////////////
// 8) solve() - orchestrates everything
///////////////////////////////////////////////
void solve(){
    int N, M;
    vector<vector<char>> rawMap;
    readInput(N, M, rawMap);

    int k = N / M; // k x k sub-sheets
    auto subSheets = extractSubSheets(N, M, rawMap);

    // Identify S, D
    auto [index_of_S, index_of_D] = findSD(subSheets);
    if(index_of_S < 0 || index_of_D < 0){
        // No valid S or D found in the sub-sheets => puzzle invalid
        cout << 0 << "\n";
        return;
    }

    // Precompute boundary compatibility
    vector<vector<bool>> rightCompat, downCompat;
    precomputeCompatibility(subSheets, rightCompat, downCompat);

    // Prepare final layout (k x k), initially -1
    vector<vector<int>> finalLayout(k, vector<int>(k, -1));
    vector<bool> used(k*k, false);

    // Force sub-sheet containing S at (0,0), sub-sheet containing D at (k-1,k-1)
    finalLayout[0][0] = index_of_S;
    used[index_of_S] = true;
    finalLayout[k-1][k-1] = index_of_D;
    used[index_of_D] = true;

    // We'll store the best distance found
    int bestDist = -1; // negative => not found yet

    // Backtracking from position 0
    backtrack(0, finalLayout, used, rightCompat, downCompat,
              subSheets, N, M, bestDist);

    // If bestDist is still -1 => no arrangement found a path
    if(bestDist < 0){
        // Problem states there's always a valid arrangement, but just in case:
        cout << 0 << "\n";
    } else {
        cout << bestDist << "\n";
    }
}


///////////////////////////////////////////////
// 9) main() - entry point
///////////////////////////////////////////////
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    solve();
    return 0;
}



2.
#include <bits/stdc++.h>
using namespace std;

// Structure to hold one entry of a bus schedule
// x, y           : coordinates of the bus stop
// arrivalTime    : the time the bus arrives at (x,y)
// departureTime  : the time the bus departs (after waiting) from (x,y)
// cumulDist      : how many "1-unit" steps the bus has traveled from its own start
struct ScheduleEntry {
    int x, y;
    int arrivalTime;
    int departureTime;
    int cumulDist;
};

///////////////////////////////////////
// Helper to parse one bus's route string
///////////////////////////////////////
vector<pair<string,int>> parseRoute(const string &routeStr) {
    // e.g., "NE4E3S1" => [("NE",4),("E",3),("S",1)]
    vector<pair<string,int>> result;
    int i = 0, n = (int)routeStr.size();
    while (i < n) {
        // Possible direction = "N","E","S","W","NE","NW","SE","SW"
        // We check if the next 2 chars form a known direction
        // Otherwise we take 1 char
        string dir;
        if (i+1 < n) {
            string maybe2 = routeStr.substr(i, 2);
            if (maybe2=="NE" || maybe2=="NW" || maybe2=="SE" || maybe2=="SW") {
                dir = maybe2;
                i += 2;
            } else {
                dir = routeStr.substr(i,1);
                i += 1;
            }
        } else {
            // only 1 char left
            dir = routeStr.substr(i,1);
            i++;
        }
        // Now read the digits for distance
        int distVal = 0;
        while (i < n && isdigit(routeStr[i])) {
            distVal = distVal * 10 + (routeStr[i]-'0');
            i++;
        }
        result.push_back({dir, distVal});
    }
    return result;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // Number of buses
    int N; 
    cin >> N;
    
    vector<pair<int,int>> busStartCoords(N);
    vector<string> busRoutes(N);
    
    // Read the bus starts and the route strings
    for (int i = 0; i < N; i++){
        int x, y;
        cin >> x >> y;
        busStartCoords[i] = {x,y};
        string route;
        cin >> route;
        busRoutes[i] = route;
    }
    
    // Read cost array, waiting time array
    vector<int> costArray(N), waitArray(N);
    for (int i = 0; i < N; i++){
        cin >> costArray[i];
    }
    for (int i = 0; i < N; i++){
        cin >> waitArray[i];
    }
    
    // Read K (number of extra bus stops)
    int K;
    cin >> K;
    
    // We'll keep a set of all known stops
    // (the final bus route endpoints are also considered stops by default)
    vector<pair<int,int>> cityStops;
    cityStops.reserve(K + 2); // just to avoid repeated reallocation
    
    for (int i = 0; i < K; i++){
        int x, y;
        cin >> x >> y;
        cityStops.push_back({x,y});
    }
    
    // Read source, destination
    int sx, sy, dx, dy;
    cin >> sx >> sy;
    cin >> dx >> dy;
    pair<int,int> source = {sx, sy};
    pair<int,int> dest   = {dx, dy};
    
    // Put city stops in a set for quick membership
    unordered_set<long long> stopsSet; // store as (x << 32) + y or something
    auto encode = [&](int xx, int yy){
        // a quick encoding of x,y into 64-bit
        return ( (long long)xx << 32 ) ^ (long long)(yy & 0xffffffff);
    };
    
    for (auto &p: cityStops){
        stopsSet.insert(encode(p.first, p.second));
    }
    // ensure source, dest are also in the set
    if (!stopsSet.count(encode(source.first, source.second))) {
        cityStops.push_back(source);
        stopsSet.insert(encode(source.first, source.second));
    }
    if (!stopsSet.count(encode(dest.first, dest.second))) {
        cityStops.push_back(dest);
        stopsSet.insert(encode(dest.first, dest.second));
    }
    
    // Direction map: each diagonal or cardinal is 1 step in time & distance
    map<string,pair<int,int>> dirMap = {
        {"N",  {0, 1}},
        {"S",  {0, -1}},
        {"E",  {1, 0}},
        {"W",  {-1,0}},
        {"NE", {1, 1}},
        {"NW", {-1,1}},
        {"SE", {1, -1}},
        {"SW", {-1,-1}}
    };
    
    // Build bus schedules
    // busSchedules[i] will be a vector of schedule entries for bus i
    vector<vector<ScheduleEntry>> busSchedules(N);
    
    // For each bus, parse route, step by step, record stops
    for (int i = 0; i < N; i++){
        int startX = busStartCoords[i].first;
        int startY = busStartCoords[i].second;
        int wTime  = waitArray[i];
        
        auto parsed = parseRoute(busRoutes[i]);
        
        vector<ScheduleEntry> schedule;
        
        // initial stop: arrivalTime=0, departureTime=0+wTime, cumulDist=0
        int currX = startX;
        int currY = startY;
        int currTime = 0; 
        int cumulDist = 0;
        
        // record the first schedule entry
        {
            ScheduleEntry e;
            e.x = currX;
            e.y = currY;
            e.arrivalTime   = 0;
            e.departureTime = 0 + wTime;
            e.cumulDist     = 0;
            schedule.push_back(e);
        }
        
        // step through each direction chunk
        for (auto &chunk: parsed){
            string dir = chunk.first;
            int dist   = chunk.second;
            auto dxy   = dirMap[dir];
            int dx = dxy.first, dy = dxy.second;
            
            for (int step = 0; step < dist; step++){
                // bus departs the last coordinate at schedule.back().departureTime
                // travel 1 minute
                int departT = schedule.back().departureTime; 
                currTime    = departT + 1; 
                
                // move 1 unit
                currX += dx;
                currY += dy;
                cumulDist += 1;
                
                // if this new (currX,currY) is a known bus stop, bus arrives at currTime and waits
                // else bus just passes through
                long long key = encode(currX, currY);
                if (stopsSet.count(key)){
                    ScheduleEntry e;
                    e.x = currX;
                    e.y = currY;
                    e.arrivalTime = currTime;
                    e.departureTime = e.arrivalTime + wTime;
                    e.cumulDist = cumulDist;
                    schedule.push_back(e);
                } else {
                    // if not a known stop, the bus has no wait => we treat departureTime = currTime
                    // But the next iteration's "departT" is from the last *actual stop* in schedule.
                    // So let's just update schedule.back()'s departureTime for continuous travel?
                    // Actually, no: we do not want to alter the last known stopâ€™s departureTime 
                    // because the bus was already "departed" from there.
                    // We'll handle final arrival below if needed.
                    
                    // The bus is effectively traveling continuously. 
                    // The "departureTime" for the next 1-unit step is the same as `currTime`.
                    // We can do a small trick: temporarily store a "fake" schedule entry? 
                    // Typically we do not store non-stops. So do nothing here:
                    // We'll continue stepping.
                }
            }
        }
        
        // The bus's final coordinate is guaranteed to be (currX, currY) after all chunks.
        // "All buses will be halted on the final bus stops." => final coordinate is a bus stop by default.
        // We must ensure the last schedule entry is that final coordinate with a final wait.
        auto &lastE = schedule.back();
        if (lastE.x != currX || lastE.y != currY) {
            // means the route ended at (currX,currY) but it wasn't appended
            // that can happen if the final route step wasn't in the set of city stops
            // But the problem states the final coordinate must also be a bus stop by default
            // So let's forcibly add it:
            ScheduleEntry e;
            // the bus arrives 1 minute after the last departureTime
            // i.e. if the bus never encountered a stop in the last chunk, we do:
            int lastDepT = lastE.departureTime;
            int arriveT  = lastDepT + 1; 
            e.x = currX;
            e.y = currY;
            e.arrivalTime = arriveT;
            e.departureTime = arriveT + wTime; 
            e.cumulDist = lastE.cumulDist + 1; 
            schedule.push_back(e);
        } else {
            // If it *is* the same coordinate but we haven't applied the final wait, do so:
            int arriveT = lastE.arrivalTime;
            // final wait:
            schedule.back().departureTime = arriveT + wTime;
        }
        
        busSchedules[i] = schedule;
    }
    
    // Build a map from (x,y) -> vector of (busIndex, scheduleIndex)
    // to see which buses and which schedule item correspond to each stop
    unordered_map<long long, vector<pair<int,int>>> busPresence; 
    for (int i = 0; i < N; i++){
        for (int sIdx = 0; sIdx < (int)busSchedules[i].size(); sIdx++){
            int xx = busSchedules[i][sIdx].x;
            int yy = busSchedules[i][sIdx].y;
            long long key = encode(xx, yy);
            busPresence[key].push_back({i, sIdx});
        }
    }
    
    // We'll do a cost-based search with time feasibility
    // State = (costSoFar, (x,y), arrivalTime)
    // Priority queue is min-heap by costSoFar
    typedef long long ll;
    struct State {
        ll cost;
        int x, y;
        int time;
        bool operator>(const State &o) const {
            return cost > o.cost;
        }
    };
    
    // We'll keep a map from (x,y) -> vector of (time, cost) for non-dominated states
    // Because K <= 20 and N <= 20, the total unique stops are not huge. 
    // We'll do an unordered_map + vector approach:
    unordered_map<ll, vector<pair<int,ll>>> best; // key=(x,y), value=list of (time, cost)
    
    // A function to check if (timeNew, costNew) is dominated by existing states
    auto isDominated = [&](ll keyCoord, int tNew, ll cNew){
        if (!best.count(keyCoord)) return false; // no states => cannot be dominated
        for (auto &st : best[keyCoord]){
            // st = (tOld, cOld)
            int tOld = st.first;
            ll cOld  = st.second;
            if (tOld <= tNew && cOld <= cNew) {
                return true; // we are dominated
            }
        }
        return false;
    };
    
    // Function to add a new state and remove any states that it dominates
    auto addState = [&](ll keyCoord, int tNew, ll cNew){
        // remove states that are dominated by this new one
        auto &lst = best[keyCoord];
        vector<pair<int,ll>> newVec;
        for (auto &st : lst){
            int tOld = st.first; 
            ll  cOld = st.second;
            // if we dominate the old => skip it
            if (tNew <= tOld && cNew <= cOld){
                // dominated => remove
            } else {
                newVec.push_back(st);
            }
        }
        newVec.push_back({tNew, cNew});
        best[keyCoord] = move(newVec);
    };
    
    priority_queue< State, vector<State>, greater<State> > pq;
    
    // Start from source with cost=0, time=0
    ll startKey = encode(source.first, source.second);
    best[startKey].push_back({0, 0});
    
    pq.push({0, source.first, source.second, 0});
    
    long long answer = -1;
    ll destKey = encode(dest.first, dest.second);
    
    while(!pq.empty()){
        auto st = pq.top();
        pq.pop();
        
        ll costSoFar = st.cost;
        int xCur = st.x, yCur = st.y;
        int tCur = st.time;
        
        if (xCur == dest.first && yCur == dest.second){
            answer = costSoFar;
            break;
        }
        // if this state is already dominated, skip
        if (isDominated(encode(xCur,yCur), tCur, costSoFar)){
            continue;
        }
        
        // check which buses are here
        ll keyHere = encode(xCur, yCur);
        if (!busPresence.count(keyHere)){
            // no bus stops here
            continue;
        }
        auto &busesHere = busPresence[keyHere]; // vector of (bus_i, idxInSchedule)
        
        // For each bus i that visits this stop
        for (auto &bi: busesHere){
            int bus_i = bi.first;
            int sIdx  = bi.second;
            
            // That bus's schedule entry
            auto &entry = busSchedules[bus_i][sIdx];
            int depT = entry.departureTime;
            int arrT = entry.arrivalTime;
            int baseDist = entry.cumulDist;
            
            // We can board if we arrive by the time it departs
            // (tCur <= depT means bus hasn't left yet).
            if (tCur <= depT){
                // We can ride forward to stops sIdx+1..end
                for (int nxt = sIdx+1; nxt < (int)busSchedules[bus_i].size(); nxt++){
                    auto &nEntry = busSchedules[bus_i][nxt];
                    int nArrT = nEntry.arrivalTime;
                    ll rideDist = (long long)nEntry.cumulDist - (long long)baseDist;
                    ll rideCost = rideDist * costArray[bus_i];
                    ll newCost = costSoFar + rideCost;
                    int newTime = nArrT; 
                    
                    ll nKey = encode(nEntry.x, nEntry.y);
                    // check dominance
                    if (!isDominated(nKey, newTime, newCost)){
                        addState(nKey, newTime, newCost);
                        pq.push({newCost, nEntry.x, nEntry.y, newTime});
                    }
                }
            }
        }
    }
    
    if (answer < 0) {
        cout << "Impossible\n";
    } else {
        cout << answer << "\n";
    }
    
    return 0;
}



3.

